#!/usr/bin/env node

const logger = require("js-logger");
logger.useDefaults();

const pathlib = require('path');
const fs = require('fs');

const {Package} = require("..");

const cmd = require("commander");


cmd.version(`v${require("../package.json").version}`, "-v --version");


cmd.command("init")
    .description("Initializes the current directory as the root of an olojs document package")
    .action(async () => {
        try {
            logger.info(`@olojs: Initializing olojs package ...`);
            const package = await Package.create(process.cwd());
            logger.info("@olojs: Package successfully initialized.");

        } catch (error) {
            logger.error(error.message);
        }
    });


cmd.command("install <plugin>")
    .description("Installs a plugin")
    .action(async (packageId) => {
        logger.info(`@olojs: installing ${packageId}`);
        try {
            const package = Package.find(process.cwd());
            await package.install(packageId);
            logger.info(`@olojs: ${packageId} plugin installed`);

        } catch (error) {
            logger.error(error.message);
        }
    });


cmd.command("uninstall <plugin>")
    .description("Uninstalls a plugin")
    .action(async (packageId) => {
        logger.info(`@olojs: uninstalling ${packageId}`);
        try {
            const package = Package.find(process.cwd());
            await package.uninstall(packageId);
            logger.info(`@olojs: ${packageId} plugin uninstalled`);

        } catch (error) {
            logger.error(error.message);
        }
    });


cmd.command("read <path>")
    .description("Fetches a document source and prints it to the stdout")
    .action(async path => {
        try {
            const package = Package.find(process.cwd());
            const store = package.require('./store');
            const fullPath = resolveDocumentPath(package, path);
            const source = await store.read(fullPath);
            console.log(source);

        } catch (error) {
            logger.error(error.message);
        }
    });


cmd.command("render <path> [args...]")
    .description("Render a document and prints it to the stdout")
    .action(async (path, args) => {
        try {
            const package = Package.find(process.cwd());
            const store = package.require('./store');
            const id = resolveDocumentPath(package, path) + '?' + args.join('&');
            const {text} = await store.load(id);
            console.log(text);

        } catch (error) {
            logger.error(error.message);
        }
    });


cmd.command("list [path]")
    .description("Lists the content of a directory")
    .action(async (path=".") => {
        try {
            const package = Package.find(process.cwd());
            const store = package.require('./store');
            const dirPath = resolveDocumentPath(package, path);
            const items = (await store.list(dirPath)).filter(name => name[0] !== '.');
            console.log(`${items.length} items found in ${dirPath}:`);
            for (let item of items) console.log(`- ${item}`);

        } catch (error) {
            logger.error(error.message);
        }
    });


cmd.command("start [port]")
    .description("Serves the current package over HTTP")
    .action(async (port=8010) => {
        try {
            const package = Package.find(process.cwd());
            const server = package.require('./server');
            await new Promise((resolve, reject) => server.listen(port, 
                        err => err ? reject(err) : resolve() ));
            console.log(`olojs server listening on port ${port}`);

        } catch (error) {
             logger.error(error.message);
        }
    });



function resolveDocumentPath (package, path) {
    const rootPath = package.resolvePath('..');
    const relativeCWD = pathlib.join('/', process.cwd().slice(rootPath.length));
    return pathlib.resolve(relativeCWD, path);
}

// Given a list of argument ['par1=val1', 'par2=val2', 'par3=val3', ...],
// converts it to an object ontaining the ke-value pair contained in the list
function parseParameters (...keyValuePairs) {
    const argns = {};
    for (let keyValuePair of keyValuePairs) {
        const separatorIndex = keyValuePair.indexOf("=");
        if (separatorIndex === -1) {
            let name = keyValuePair.trim();
            if (isValidName(name)) argns[name] = true;
        } else {
            let name = keyValuePair.slice(0, separatorIndex).trim();
            if (isValidName(name)) {
                let string = keyValuePair.slice(separatorIndex+1).trim();
                let number = Number(string);
                argns[name] = isNaN(number) ? string : number;
            }
        }
    }
    return argns;
}

const isValidName = val => /^[a-z_A-Z]+[a-z_A-Z0-9]*$/.test(val);


cmd.parse( process.argv );
